{"componentChunkName":"component---src-templates-blog-post-js","path":"/oracle-sql-기준이-다른-테이블-데이터-클렌징-하기/","result":{"data":{"markdownRemark":{"html":"<p>어떤 data가 한 화면을 통해서 2개의 테이블에 동시에 입력되는데, 두 테이블의 기준이 되는 값이 (pk) 달랐다. 하나는 unique한 번호 기준이며, 다른 하나는 사람 (특정 관계자) 기준이다.  </p>\n<p>어떤 컬럼에 숫자만 들어가야 하는데, 화면에 제어 로직이 없었어서 잘못된 데이터 타입이 들어가 있었다. 그래서 일괄적으로 default 값인 '00000'으로 업데이트를 진행하게 됐다. 또, 어떤 컬럼에는 한글이어야 하는데 값이 없는 경우가 있었다.</p>\n<p>그런데, 화면을 잘못 사용해서 같았던 데이터가 정합성 문제가 생겨 같은 데이터가 맞는지 판단히 애매한 경우 건들이 일부 있었다.  </p>\n<p>두 테이블이 셋트이다 보니까, 같은 data가 맞다는 전제 하에 둘다 이상한 값이 들어간 경우에 한해서만 데이터 update를 하고 싶었다.  </p>\n<p>결국, <strong>MERGE INTO 를 사용하여</strong> <u>두 테이블의 데이터가 일치한다고 판단되는</u> 건들 중 (WHEN MATCHED THEN만 사용), 둘다 잘못된 case를 '00000'로 일괄적으로 UPDATE 처리 했다.  </p>\n<hr>\n<p>데이터 정합성 개선 작업 순서는 다음과 같다.</p>\n<p>[1] 두 테이블이 같은 건으로 확인되는데, 그럼에도 컬럼 값이 서로 다른 경우<br>\n=> 어쩔 수 없이 확인 후 건별로 데이터 수정 (전체 데이터의 0.01% 미만)</p>\n<p>[2] 두 테이블이 join이 가능한 경우</p>\n<ul>\n<li>\n<p>A 테이블 작업 예시  </p>\n<pre><code class=\"language-sql\">MERGE INTO A using(\nSELECT A.pk들 FROM A join B 테이블 ... WHERE A.컬럼 ~ ) AA\nON {AA.pk들 = A.pk들 }\nWHEN MATCHED THEN\nUPDATE\nSET AA.컬럼2 = '미상' AND AA.컬럼 = '00000';\n</code></pre>\n</li>\n<li>\n<p>B 테이블 작업 예시 (A와 B 데이터 갯수는 n:1이어서 distinct를 사용했다.)  </p>\n<pre><code class=\"language-sql\">MERGE INTO B using(\nSELECT distinct B.pk들 FROM B join A 테이블 ... WHERE B.컬럼 ~ ) BB\nON {BB.pk들 = B.pk들 }\nWHEN MATCHED THEN \nUPDATE SET BB.컬럼2 = '미상' BB.컬럼 = '00000';\n</code></pre>\n</li>\n</ul>\n<p>=> 위 작업은 3번 반복되었다. 그냥 UPDATE 문으로 해도 된다지만, 두 테이블이 set이라서 같은 유형끼리 같은 시간에 수정되게 나눠서 진행했다. (...)  </p>\n<ol>\n<li>두 컬럼 다 둘다 null인 경우</li>\n</ol>\n<p>ex)</p>\n<pre><code class=\"language-sql\">MERGE INTO TABLE A\nUSING( SELECT A.pk들\n        FROM A\n      INNER JOIN B\n        ON ...\nWHERE A.컬럼 IS NULL AND A.컬럼2 IS NULL\n  AND B.컬럼 IS NULL AND B.컬럼2 IS NULL\n        ) AA\nON (A.pk들 = AA.pk들)\nWHEN MATCHED THEN\nUPDATE\n SET AA.컬럼  = 'asdfzxv35as!@5684e', // 고유식별번호라 00000의 복호화 값이 들어감\n     AA.컬럼2 = '미상'\n    ;\n</code></pre>\n<p>ex)</p>\n<pre><code class=\"language-sql\">MERGE INTO TABLE B\nUSING( SELECT distinct B.pk들, A.컬럼, A.컬럼2\n        FROM B\n      INNER JOIN A\n        ON ...\nWHERE B.컬럼 IS NULL AND B.컬럼2 IS NULL\n  AND A.컬럼='미상' AND A.컬럼2 = 'asdfzxv35as!@5684e' &#x3C;- 위에서 수정한 값\n        ) AA\nON (B.pk들 = BB.pk들)\nWHEN MATCHED THEN\nUPDATE\n SET BB.컬럼  = B.컬럼, // A 테이블 (위에서 수정한) 값\n     BB.컬럼2 = B.컬럼2 // A 테이블 (위에서 수정한) 값\n    ;\n</code></pre>\n<ol start=\"2\">\n<li>컬럼2가 null 인 경우</li>\n<li>컬럼이 null인 경우</li>\n</ol>\n<p>[3] 두 테이블이 join 되지 않는 건\n=> 각각 update 쿼리 사용 (전체 데이터의 0.1% 미만)</p>\n<p>** 이미지 파일을 건별로 확인하는 게 오래 걸려서 더 이상 수정은 불가했다.</p>","tableOfContents":"","frontmatter":{"title":"데이터 클렌징 작업 - 정합성 개선 (by SQL Merge Into 구문)"}}},"pageContext":{"slug":"/oracle-sql-기준이-다른-테이블-데이터-클렌징-하기/"}},"staticQueryHashes":["3159585216"]}