{"componentChunkName":"component---src-templates-blog-post-js","path":"/oracle-sql-기준이-다른-테이블-데이터-클렌징-하기/","result":{"data":{"markdownRemark":{"html":"<p>어떤 data가 한 화면을 통해서 2개의 테이블에 동시에 입력되는데, 두 테이블의 기준이 되는 값이 (pk) 달랐다. 하나는 unique한 번호 기준, 다른 하나는 사람 기준이다.<br/><br/>어떤 컬럼 숫자만 들어가야 하는데, 화면에 제어 로직이 없었어서 잘못된 데이터 타입이 들어가 있었다. 그래서 일괄적으로 default 값인 '00000'으로 업데이트를 진행하게 됐다. <br/><br/>그런데, 화면을 잘못 사용해서 같았던 데이터가 정합성 문제가 생겨 같은 데이터가 맞는지 판단히 애매한 경우 건들이 일부 있었다.<br/><br/>두 테이블이 셋트이다 보니까, 같은 data가 맞다는 전제 하에 둘다 이상한 값이 들어간 경우에 한해서만 데이터 update를 하고 싶었다. <br/><br/>결국, <b> MERGE INTO 를 사용해 <u>두 테이블의 데이터가 일치한다고 판단되는</u> 건들 중 (WHEN MATCHED THEN만 사용)</b>, 둘다 잘못된 case를 '00000'로 일괄적으로 UPDATE 처리 했다.</p>\n<ol>\n<li>A 테이블 작업</li>\n</ol>\n<p>MERGE INTO A AA using(SELECT A.* FROM A join B 테이블 ... WHERE A.컬럼 ~ ) ON {AA.pk들 = A.pk들 WHEN MATCHED THEN UPDATE SET AA.컬럼 = '00000';</p>\n<ol start=\"2\">\n<li>B 테이블 작업</li>\n</ol>\n<p>MERGE INTO B BB using(SELECT B.* FROM B join A 테이블 ... WHERE B.컬럼 ~ ) ON {BB.pk들 = B.pk들 WHEN MATCHED THEN UPDATE SET BB.컬럼 = '00000';</p>\n<ol start=\"3\">\n<li>두 테이블 join이 안 되어서 1), 2)에 포함되지 않은 건 => 수정 보류</li>\n<li>두 테이블 join은 되는데, 두 테이블의 이 컬럼이 다른 경우 => 수정 보류</li>\n</ol>\n<p>** 이미지 파일을 건별로 확인하는 게 오래 걸려서 더 이상 수정은 불가했다.</p>","frontmatter":{"title":"데이터 클렌징 작업 - 정합성 개선 (by SQL Merge Into 구문)"}}},"pageContext":{"slug":"/oracle-sql-기준이-다른-테이블-데이터-클렌징-하기/"}},"staticQueryHashes":["3159585216"]}