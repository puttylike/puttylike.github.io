{"componentChunkName":"component---src-templates-blog-post-js","path":"/ai-이노베이션-스퀘어-10일차/","result":{"data":{"markdownRemark":{"html":"<h3 id=\"10일차\" style=\"position:relative;\">10일차<a href=\"#10%EC%9D%BC%EC%B0%A8\" aria-label=\"10일차 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>오늘은 어제에 이어 계속 문제를 풀어 나갔다. 하나 하나의 문제점을 짚어가는 부분이 마음에 든다. 단순히 알고만 있던 지식의 파편이 완성되는 느낌. 역시 모든 것에는 이유가 있다.  </li>\n<li>오늘 강의를 끝으로 절반을 돌파했다.<br>\n앞으로 내가 할 방향에 대한 고민을 해야할 시점이지 않나 싶다.  </li>\n</ul>\n<h4 id=\"메모\" style=\"position:relative;\">메모<a href=\"#%EB%A9%94%EB%AA%A8\" aria-label=\"메모 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<ul>\n<li>★ dynamic programming concept > programming = plan  </li>\n<li>★ class design pattern > class method는 기능에 집중해야 한다</li>\n<li>★ train / tset split => 과적합 over-fitting 방지</li>\n</ul>\n<hr>\n<h3 id=\"문제-풀이-시간에-배운-점-어제에-이어서\" style=\"position:relative;\">문제 풀이 시간에 배운 점 (어제에 이어서)<a href=\"#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%8B%9C%EA%B0%84%EC%97%90-%EB%B0%B0%EC%9A%B4-%EC%A0%90-%EC%96%B4%EC%A0%9C%EC%97%90-%EC%9D%B4%EC%96%B4%EC%84%9C\" aria-label=\"문제 풀이 시간에 배운 점 어제에 이어서 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>​</p>\n<h4 id=\"예제2\" style=\"position:relative;\">예제2<a href=\"#%EC%98%88%EC%A0%9C2\" aria-label=\"예제2 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>은닉층 1개를 가지는 신경망 기반의 AND, OR, NAND, XOR 기능 각각 구현하기.</p>\n<ul>\n<li>insight?<br>\n히든 레이어 1개 5초 걸리면, 2개이면 10초 이상 걸리는 꼴이니,<br>\n동일한 정확도이면 히든 레이어 적게 하는 게 좋다.</li>\n</ul>\n<p>히든 레이어 1개여도, 2개여도 데이터에 변화를 주니,<br>\n히든 레이어 변화로 다양한 y가 (반응이) 나올 수 있다.</p>\n<p>$a2 = sig(x*w2+b2)$ * sigmoid 함수<br>\n$y = a3 = sig(a2*w3+b3)$  </p>\n<p>​해 보면, 히든 레이어 1개로 하면 XOR은 잘 안 된다.<br>\n2개부터가 될 수도, 안 될 수도 있는데, 이는 환경마다 다르기 때문이다.</p>\n<p><strong>* 히든 노드가 하나라도 있어야 딥러닝, 없으면 머신 러닝</strong></p>\n<hr>\n<h4 id=\"예제4\" style=\"position:relative;\">예제4<a href=\"#%EC%98%88%EC%A0%9C4\" aria-label=\"예제4 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>은닉층 1개를 가지는 LogicGate 클래스 만들기.  </p>\n<p>은닉층을 추가하게 되면, 거기의 W4, b4 추가가 필요하고, feed forward 변경을 해야 하고, 이에 따른 predict 변경도 필요하다.</p>\n<p><strong>\"Simple is best\"</strong></p>\n<p>레이어 1개 쓰는 대신, 노드 늘리는 게 더 심플하다.​​</p>\n<p>가령, 어떤 문제를 풀 때 h1 노드 최소 4개가 필요한데, (2-4-1)<br>\n이 상황에서 히든레이어 h2 를 둘 거라면, (2-?-?-1)<br>\n이 2번째 레이어를 두는 게 의미가 있으려면 이 위의 ?-?는 1-1을 넘으면 안 된다.</p>\n<p>이 경우, 2-1 쓰느니, 4 하나가 낫다.</p>\n<p>레이어를 하나 더 뒀다는 건, 복잡도가 증가했으니 노드 수 에서 이득을 봐야 한다.<br>\n레이어 하나로 풀리면 굳이 레이어 여러 개 둘 필요가 없다.</p>\n<ul>\n<li>다시 말해, 레이어를 증가할 땐 타당성이 었어야 한다.<br>\n레이어 수, 레이어 내 노드 수는 hyper parameter이긴 하지만.</li>\n<li>시스템 성능이 안 좋을 때, last consideration은? 아키텍처 변경.<br>\n아키텍처 변경은 최후의 수단이다. 아키텍처 바꾸면 모든 걸 다 바꿔야 하기 때문이다.\n...그러니까 애초에 simple하게 만들자.</li>\n</ul>\n<p>마찬가지로, layer 추가 > <strong>init</strong>, predict feedforward, train까지 다 영향이 감</p>\n<p>...DB 아키텍처 스키마 이듯, 딥러닝 아키텍처 는 레이어다.</p>\n<hr>\n<h4 id=\"예제5\" style=\"position:relative;\">예제5<a href=\"#%EC%98%88%EC%A0%9C5\" aria-label=\"예제5 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>cf. <a href=\"http://archive.ics.uci.edu/ml/index.php\">http://archive.ics.uci.edu/ml/index.php</a><br>\ndiabetes.csv<br>\n=> 이 데이터는, 759행 9열 이다.<br>\n=> 입력 노드8 정답 노드1개 필요하다.</p>\n<p>코드의 문제점... 일단, 시간이 너무 오래 걸린다.<br>\n노드 10개에 30분, 노드 30개에 3시간 소요된다고.</p>\n<ul>\n<li>시간이 오래 걸리는 이유는 train 메소드 내 미분 부분 때문이다.<br>\n$αloss/ αw$ => 나누기, diabetes 759 rows인데, 이것의 affect는?</li>\n</ul>\n<p>미분 횟수가 8x10x759(입력노드 x h1 노드 x 행 수)...<br>\n=> 1 cycle 에 미분 횟수가8x10x759x4 (위에서 구한 값 x 4개(w2,b2,w3,b3) )<br>\n이래서 오래 걸린다.</p>\n<ul>\n<li>loss는 왜 큰 값일까?  </li>\n</ul>\n<p>ex. Y1을 계산하기 위해 W1, 필요 Y1으로 나온게 loss / 업데이트된 W인 W2, W2로 나온게 Y2...</p>\n<p>평균적으로 가장 오차가 작은 가중치를 적용하는 거라,<br>\n데이터 10개 중 8개에는 잘 적용될 수 있고, 2개는 적용 안 될 수도 있다.</p>\n<p>759개에 대해 다 적용시킨 거다 보니까 값이 별로 안 줄어 든다.<br>\ndata가 많아져서 그만큼 곱해지는 애들이 많고 그래서 평균치가 나온 거니까.</p>\n<p>평균적으로 가장 작은 오차를 낼 수 있다면 그 일부를 선택하면 되는 것이니,<br>\n<strong>굳이 통째로 최적화 시킬 필요가 없다.</strong>\n​</p>\n<ul>\n<li>1행씩 보내서 759번 반복하는 방법은 어떨까?<br>\n대신, 평균적으로 loss를 줄이는 방향으로 가면 된다.</li>\n</ul>\n<p>위에서 for 30000 759행 업데이트 를 했는데,<br>\nfor 30\nfor 759 1행 update 로 바꿔 보자.</p>\n<p>이 변화로 loss가 작아진다는 건 w가 잘 맞게 됐다는 반증이다.  </p>\n<p>759개에 대해 w 구하고, loss값을 구하게 로직을 수정한다.<br>\n<del>(train 안에서 for 제거, 밖에서 for문 2번)</del></p>\n<p>​___</p>\n<h4 id=\"예제6\" style=\"position:relative;\">예제6<a href=\"#%EC%98%88%EC%A0%9C6\" aria-label=\"예제6 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>안쪽 for w2,w3,b2,b3 update - 759번실행 을<br>\n바깥쪽 for 20번\n​  다음 행에 이전 updated w2,w3,b2,b3가 적용된다.</p>\n<p>통으로 하나, 하나 씩해서 총 20번 하나 한 행씩 하나 결국 같다.\n=> 매우 중요한 프로그램 테크닉</p>\n<p>cf. 분할정복 divide &#x26; conquer</p>\n<p>cf. dynamic programming > 강화학습 벨만방정식 풀 때 중요함</p>\n<p>동적 프로그래밍 큰 문제를 한 번에 해결하기 힘드 때 작은 여러 개의 문제로 나누어서 푸는 기법이다.​</p>\n<p>cf. 벨만 방정식<br>\n$V_pi(s) = ∑ π(a|s)P(s'|s,a)[r(s,a,s')+γ V_pi(s')]$ (s' 다음상태 s 현재상태)</p>\n<p>함수 다 풀 수 없으니 강화학습에서 current state는 next state만 영향을 받는다,고 보는 거를 dynamic이라 볼 수 있다. (= 현재 상태만 고려함)</p>\n<ul>\n<li>ML - train 내에 for문 없고, train에 입력 data 바로 줌, 바깥에서 for문 씀</li>\n</ul>\n<p>for epochs 전체 횟수<br>\nfor 각행 update (train)</p>\n<p>cf. tensorflow가 빠른 건, 모든 데이터를 텐서로 통일시켰고, gpu 이용하는 라이브러리가 있기 때문이다. cuda가 내부적으로 돼 있댜.</p>\n<p>cf. gpu 쓰는 라이브러리 cuda => 이걸 써서 코딩해야 빨라진다.</p>\n<p>cf. 케라스 코드 : model.fit\n​</p>\n<hr>\n<h4 id=\"예제6-1\" style=\"position:relative;\">예제6'<a href=\"#%EC%98%88%EC%A0%9C6-1\" aria-label=\"예제6 1 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-python line-numbers\"><code class=\"language-python\">target_data <span class=\"token operator\">=</span> test_data<span class=\"token punctuation\">[</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<p>=> 정답이 마지막 열에 있다는 가정이 있다.<br>\n=> 즉, 현재의 accuracy 함수는 범용성이 떨어진다.  </p>\n<p>test_data에 따라 class를 계속 바꿔줘야 하는 건 뭔가 말이 안 된다.<br>\nclass는 data type이기 때문이다.</p>\n<p>​=> def accuracy(self, test<em>input, test</em>target): 이런 식으로 바꿔야 맞다.</p>\n<p>현재 accuracy method의 모습이라면, 정답의 위치에 따라 method를 계속 만들어야 한다.<br>\n<strong>api는 기능에 충실해야 한다.</strong></p>\n<p>​사실, accuracy는 정확도 측정이 목적이니, 위에  </p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-python line-numbers\"><code class=\"language-python\">input_data <span class=\"token operator\">=</span> test_data<span class=\"token punctuation\">[</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\ntarget_data <span class=\"token operator\">=</span> test_data<span class=\"token punctuation\">[</span> <span class=\"token punctuation\">:</span> <span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token punctuation\">]</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>이런 부분은 없는 게 맞다.</p>\n<hr>\n<h4 id=\"예제7\" style=\"position:relative;\">예제7<a href=\"#%EC%98%88%EC%A0%9C7\" aria-label=\"예제7 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>W,b는 training data에 최적화 돼 loss가 최소화 된다.  </p>\n<p>ML이란 학습 데이터에 없는 data를 줘서 미래 값을 예측해야 하는건데,<br>\ntraining data = test data이면,<br>\n다시 말해 같은 data를 test 때 주는 건 ML하는 의미가 없다.</p>\n<p>=> over fitting ! (과적합 문제)</p>\n<p>ML의 문제를 대표적으로 하나만 뽑자면, over fitting 문제가 있다.<br>\n★ training data 최적화</p>\n<p>=> 해결책은? dropout 등등 있겠다만,<br>\n여기서는 학습 데이터, 테스트 데이터 분리하는 방법을 쓴다.</p>\n<ul>\n<li>전체 data에서 training : test =7:3 or 8:2 비율</li>\n</ul>\n<p>데이터는 어떻게 분리할까? 엑셀 노가다 말고 없을까?</p>\n<p>====\n담주에 mnist / 오차역전파?까지 할 듯</p>\n<p>데이터 분리를 원하는 비율로 하기 위해 data generation class 만들 예정이다.</p>\n<p>cf. scikit learn train test split</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"/ai-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%80%98%EC%96%B4-10%EC%9D%BC%EC%B0%A8/#10%EC%9D%BC%EC%B0%A8\">10일차</a></p>\n<ul>\n<li><a href=\"/ai-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%80%98%EC%96%B4-10%EC%9D%BC%EC%B0%A8/#%EB%A9%94%EB%AA%A8\">메모</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"/ai-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%80%98%EC%96%B4-10%EC%9D%BC%EC%B0%A8/#%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%8B%9C%EA%B0%84%EC%97%90-%EB%B0%B0%EC%9A%B4-%EC%A0%90-%EC%96%B4%EC%A0%9C%EC%97%90-%EC%9D%B4%EC%96%B4%EC%84%9C\">문제 풀이 시간에 배운 점 (어제에 이어서)</a></p>\n<ul>\n<li><a href=\"/ai-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%80%98%EC%96%B4-10%EC%9D%BC%EC%B0%A8/#%EC%98%88%EC%A0%9C2\">예제2</a></li>\n<li><a href=\"/ai-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%80%98%EC%96%B4-10%EC%9D%BC%EC%B0%A8/#%EC%98%88%EC%A0%9C4\">예제4</a></li>\n<li><a href=\"/ai-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%80%98%EC%96%B4-10%EC%9D%BC%EC%B0%A8/#%EC%98%88%EC%A0%9C5\">예제5</a></li>\n<li><a href=\"/ai-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%80%98%EC%96%B4-10%EC%9D%BC%EC%B0%A8/#%EC%98%88%EC%A0%9C6\">예제6</a></li>\n<li><a href=\"/ai-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%80%98%EC%96%B4-10%EC%9D%BC%EC%B0%A8/#%EC%98%88%EC%A0%9C6-1\">예제6'</a></li>\n<li><a href=\"/ai-%EC%9D%B4%EB%85%B8%EB%B2%A0%EC%9D%B4%EC%85%98-%EC%8A%A4%ED%80%98%EC%96%B4-10%EC%9D%BC%EC%B0%A8/#%EC%98%88%EC%A0%9C7\">예제7</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"AI 이노베이션 스퀘어 12기 기본반 10일차 후기"}}},"pageContext":{"slug":"/ai-이노베이션-스퀘어-10일차/"}},"staticQueryHashes":[]}