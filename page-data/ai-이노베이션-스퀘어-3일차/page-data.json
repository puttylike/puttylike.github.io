{"componentChunkName":"component---src-templates-blog-post-js","path":"/ai-이노베이션-스퀘어-3일차/","result":{"data":{"markdownRemark":{"html":"<h3>3일차</h3>\n<p>금일 오전에는 function과 class를, 이어서 lambda를 배웠다. 문제 풀이는 내일 오전에 진행된다고. 점점 예제 문제가 어려워지는 것 같다.\n<br/><br/></p>\n<hr>\n<h3>1. function</h3>\n<p>(1) 데이터 타입을 안 써도 된다.</p>\n<p>def sum(x, y):<br/>\ns = x+y;<br/>\nreturn s;<br/>\ncf. C언어 : int sum(int x, int y)</p>\n<p>(2) 1개 이상의 값을 반환할 수 있다 - 문법적으로 허용된다.</p>\n<p>(3) return 값은 ,로 분리하거나 tuple 형태로 받을 수 있음.<br/>\ncf.  C언어 : 구조체 Struct / C++/Java : 객체 Object를 써야 하지만.</p>\n<p>(4) default parameter에 대하여\n함수명 옆( , count = 2);<br/>\n=> 여기서 count는 default parameter<br/>\n참고로 default 파라미터는 끝에서 부터 <br/>(순서 : (&#x3C;--,--,--여기가시작  )) 값을 채워야 한다<br/>\n이는 stack 메모리 에 저장되기 때문이다</p>\n<p>(name,count) 이면 이렇게 저장돼 count먼저 사라지는데,<br/>\n[count]<br/>\n[name]<br/>\n(name,var=2,count) 이면\nvar이 나가기 전에 count 값 없어서 error 발생이라고.</p>\n<p>(5) mutable/immutable\nmutable 에는... list, dict, numpy 등 연속데이터가 저장되는 데이터 변수가 해당된다. int 등과는 다르게 따로 메모리 안 생기고 함수와 공유하기 때문에, 원본 데이터 변형이 일어난다.\n그래서 함수 안에서 각각의 element 값을 가져와서 임시 변수에 저장하여 써야 한다.<br/>\n<br/>​\n(반복 작업)<br/>\ntemp = x[idx]<br/>\n사용 후<br/>\nx[idx] = temp<br/><br/>\ncf. C언어에서는 포인트, java에서는 reference &#x26; 원본이 변한다</p>\n<ul>\n<li>mutable - ist / dict / numpy 등 연속 데이터임을 외우자<br/></li>\n</ul>\n<hr>\n<h3>2. 람다 lambda</h3>\n<p>(1) f = lambda x: x+100 => 수학 함수표현 f(x) 를 x+100 으로 대체한다는 의미<br/>=> 수학 공식을 표현할 때 직관성이 높아진다.<br/>그래서 ML에서는 직관적으로 수학 공식을 표현하기 위해 람다를 쓴다.\n<br/><br/>\nfx = lambda x,y : test_<em>lambda(s,t)<br/>\n=> 수학적으로 입력변수를 표현했을 뿐 꼭 쓰는 건 아니다. 여기서 x, y를 안 쓰는 거처럼 <br/>\nex) f(x+delta x) => self.feed</em>forward() : x나 delta x는 없고 걍 실행임<br/>\n<br/>\ncf. Last in First out Lifo 구조 - stack : 앞부터 저장, 꺼낼 땐 반대부터.<br/>그래서 default 파라미터는 거꾸로 채워야 하는 것이었다.<br/></p>\n<ul>\n<li>lambda는 소스코드에 수학공식 넣고 싶을 때 사용. 실행 시 run time에서 lambda x, y : 뒤에 적힌 거로 대체된다.</li>\n</ul>\n<p>​cf. C언어 symbolic link, 파이썬에서는 lambda</p>\n<hr>\n<h3>3. 문제 풀이 시간에 배운 점</h3>\n<p>예제 6. f = lambda x : func(c) => f(x)가 나오면 func(x)로 대체하라<br/>\nret<em>val = test</em>func(f,[1.0,2.0]) # 함수 포인터 형태</p>\n<p>cf. 함수 포인터에 대하여<br/>\nC언어에서 함수가 저장된 주소값은 함수이름이다....<br/>\nex) 디스플레이 해상도 설정 - 함수 포인트 # 너무 오래걸려서 ㅠ</p>\n<p>W[0] = W[0]+0.1 # mutable<br/>\n= f(w) 나오면 실행되는 것, 그래서 함수 포인트.</p>\n<p>cf. C 함수포인터 유튜브 인강 참고</p>\n<hr>\n<h3>4. Class 클래스</h3>\n<p>\"class is same as user defined data type\"<br/><br/>\n(1) Class는 데이터 타입의 일종이다. 맨날 붕어빵 틀 얘기만 들었는데, 개념이 명확해졌다.</p>\n<p>cf. C++언어\nmain(){</p>\n<p>  int a= 10;\nint a(10); => int class라 ok</p>\n<p>...</p>\n<p>}​</p>\n<p>=> int a = 10; 에서 알 수 있는 점?<br/>\n데이터타입,메모리크기,값 4byte 를 알 수 있다.<br/>\n또한, a^^30 이렇게 해도 안 되고, 연산자 = 를 써야 한다는 걸 알 수 있다.<br/></p>\n<p>알 수 있는 점을... 정리하면 다음과 같다. <br/></p>\n<ol>\n<li>필요한 메모리 크기<br/></li>\n<li>저장 data 종류<br/></li>\n<li>데이터 입출력을 위해선 정해진 연산자가 필요하다<br/></li>\n<li>변수이름으로 최종적으로 메모리에 생성<br/></li>\n</ol>\n<p>(2) 멤버 메소드를 통해 class 내의 멤버에 접근할 수 있다.</p>\n<p>(3) user defined data type이다. 즉, 클래스는 내가 원하는 데이터 타입을 만들 수 있다. <br/>class로 묶어주면 통으로 메모리에 갖고 있을 수 있다. 기존 컴파일러에 없던 데이터타입을 만드는 게 클래스이다.</p>\n<p>(4) method는 = 처럼 class 내 멤버에 어떻게 접근할 지 알려준다.<br/>\nex. 내가 만든 데이터 타입을 컴퓨터는 class Person... Person이 뭔지 모른다. 그래서 접근 방법을 def 알랴줌. 그게 method이다.</p>\n<p>\"class = member + method\"</p>\n<p>cf. set 설정하기, get 가져오기, 이 둘은 셋트.<br/></p>\n<p>cf. ​Date Class getTime() = class Date 안에 time이 있는거지...<br/>\n이게 class라고! getTime() setTime()</p>\n<p>(5) 클래스 메서드의 첫번째 인수로 자신의 인스턴스를 나타내는 self를 반드시 써야 한다.<br/>\ncf. java의 this. <br/><br/>\nself.name 이렇게 self.으로 내가 갖고 있는 member를 표현한다.</p>\n<p>obj = Person(\"PARK\")에서 class Person을 찾는다. <br/>생성자는 __ init __ 이렇게 붙여 쓴다.</p>\n<p>(6) class 를 design 해라 ?</p>\n<ol>\n<li>내가 어떤 데이터를 몇개 보관하고 있을 지 정해야 한다.</li>\n<li>보관하고 있는 데이터에 어떻게 접근할 건지 method를 만든다.</li>\n</ol>\n<p>ex) class Person: 나이, 국적, 성별,,,\nex) myCalC 계산기 : 숫자 최소 2개 필요</p>\n<p>​cf. 윈도우 하단 시간 누르면 시간이 보이는데, 이게 getTime() 시간 바꾸는 건 setTime()</p>\n<p>(7) 파이썬은 기본적으로 member public / method public 이다.<br/> 그래서 method 없이 obj에 바로 접근 가능하다. 그래서 obj.getName() 안 쓰고 obj.name를 써도 무방하다.</p>\n<ul>\n<li>private로 쓰기<br/>\n기본이 public이니 private를 쓰고 싶다면,<br/>\n__멤버변수, __멤버메서드 -> private<br/></li>\n</ul>\n<p>​\n(8) 클래스 내부에서는 private 개념이 없다. <br/>그래서 private 접근이 가능하다.<br/>\n어디까지나 public / private 는 external access 외부 접근 관련일 뿐이다.</p>\n<p>클래스 내부는 self.메소드<br/>\n외부 함수는 함수</p>\n<ul>\n<li>반드시 멤버에 접근해야 하면 method. 하지만 이 클래스에서만 쓰지 않고 공용으로 쓰는 거면 내부에 가져올 필요가 없다.</li>\n<li>method는 멤버에 접근하기 위함. 일반적인 출력을 위해서면 class 내부로 가져올 필요가 없다.</li>\n</ul>\n<p>​cf. xor 문제 유튜브 강의 : 미분함수 : logicgate에서만 쓰는게 아니니까 external function\n정리하면, 내부에서만 쓸 거면 class 안에, 아니면 걍 밖에 꺼내 두자.</p>\n<hr>\n<h3>5. with 구문</h3>\n<p>응용프로그램이 응답하지 않습니다 > close() 안 해서 생기는 문제이다. <br/>소캣 등... 리소스는 open하면 close를 해야 한다. <br/><br/>그래서 with을 쓰면 with이 끝나는 순간 모든 리소스가 자동으로 close 되기 때문에 유용해서 잘 쓰이는 구문. ml에서는 session 사용 시 자주 쓰인다.<br/><br/>\ncf. 자동 미분 tape gradient : <a href=\"https://tensorflow.org/api_docs/python/tf/GradientTape\">https://tensorflow.org/api_docs/python/tf/GradientTape</a></p>\n<hr>\n<h3>6. exception 예외처리</h3>\n<p>(1) error / except ?<br/>\nerror는 always라 고쳐야 하는 건데,<br/>\nexception은 sometimes라 경우에 따라 생길 수도 안 생길 수도 있다는 점에 차이가 있다.</p>\n<p>cf. java try catch / python try exception</p>\n<ul>\n<li>finally는 debugging이 힘들어지므로 비추.</li>\n</ul>\n<p>​(2) try에서 예기치 못한 상황이 발생하면 except</p>\n<p>cf. curse of demo day : 실행환경 / 개발환경이 바뀐 경우인 편.<br/>=> 이렇게 내 의지와 상관없는 문제가 생길 때, exception을 쓰자.<br/></p>\n<ol>\n<li>file I/o 작업<br/></li>\n<li>네트워크 문제<br/></li>\n</ol>\n<p>=> 환경이 달라질 거를 예측해서 except 예외처리 하자.\nexcept 처리 안 하면 프로그램이 죽음 = 최악의 경우이다. <br/><b>if가 있으면 항상 거쳐가니까 느려지므로 if로 하지 말고 except 처리하자.</b></p>\n<p>except는 정상적인 환경에선 코드가 잘 실행된다. cpu interrupt 개념이라 문제 있을 때만 interrupt되어 실행되니까 if 쓰지 말자.<br/><br/>cf. java file read <a href=\"https://vmpo.tistory.com\">https://vmpo.tistory.com</a></p>\n<p>(3) raise - 강제로 인위적인 exception 발생시키는 방법이다.\nex. 강제로 exception 발생시키는 경우 : raise reboot 강제로 재부팅할 때 ㅋㅋㅋ</p>\n<ul>\n<li>except 처리를 잘 한 다는 거는 그 환경을 100% 이해한다는 것이다 !</li>\n</ul>","frontmatter":{"title":"AI 이노베이션 스퀘어 12기 기본반 3일차 후기"}}},"pageContext":{"slug":"/ai-이노베이션-스퀘어-3일차/"}},"staticQueryHashes":["3159585216"]}